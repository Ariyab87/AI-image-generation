import streamlit as st
import numpy as np
import plotly.graph_objects as go
import plotly.express as px
from PIL import Image, ImageDraw, ImageFont
import io
import base64
from datetime import datetime
import os
from pathlib import Path
import torch
from diffusers import StableDiffusionPipeline
import time

# Initialize Stable Diffusion with a smaller model
@st.cache_resource
def load_pipeline():
    # Use a smaller, faster model
    model_id = "CompVis/stable-diffusion-v1-4"
    pipe = StableDiffusionPipeline.from_pretrained(
        model_id,
        torch_dtype=torch.float32,
        safety_checker=None  # Disable safety checker for speed
    )
    if torch.cuda.is_available():
        pipe = pipe.to("cuda")
    else:
        # Enable CPU optimization
        pipe = pipe.to("cpu")
        pipe.enable_attention_slicing()
        pipe.enable_sequential_cpu_offload()
    return pipe

# Page configuration
st.set_page_config(
    page_title="Prompt to 3D Generator",
    page_icon="ðŸŽ¨",
    layout="wide"
)

# Custom CSS for better styling
st.markdown("""
<style>
    .main-header {
        font-size: 3rem;
        color: #1f77b4;
        text-align: center;
        margin-bottom: 2rem;
    }
    .sub-header {
        font-size: 1.5rem;
        color: #ff7f0e;
        margin-bottom: 1rem;
    }
    .stButton > button {
        width: 100%;
        height: 3rem;
        font-size: 1.2rem;
    }
    .result-box {
        border: 2px solid #1f77b4;
        border-radius: 10px;
        padding: 1rem;
        margin: 1rem 0;
    }
</style>
""", unsafe_allow_html=True)

def create_image(prompt, size=(512, 512)):
    """Generate an image using Stable Diffusion"""
    try:
        # Show loading message
        with st.spinner(f"ðŸŽ¨ Generating image for: {prompt}"):
            # Load the pipeline
            pipe = load_pipeline()
            
            # Start timer
            start_time = time.time()
            
            # Generate the image with a timeout
            width, height = size
            image = pipe(
                prompt,
                width=width,
                height=height,
                num_inference_steps=20  # Reduce steps for faster generation
            ).images[0]
            
            # Show generation time
            generation_time = time.time() - start_time
            st.info(f"âœ¨ Image generated in {generation_time:.2f} seconds")
            
            return image
    except Exception as e:
        st.error(f"Error generating image: {str(e)}")
        # Fallback to demo image if there's an error
        return create_demo_image(prompt, size)

def create_demo_image(prompt, size=(512, 512)):
    """Create a demo image based on the prompt"""
    # Create a gradient background
    img = Image.new('RGB', size, color='#2E3440')
    draw = ImageDraw.Draw(img)
    
    # Try to use a system font
    try:
        font_large = ImageFont.truetype("/System/Library/Fonts/Arial.ttf", 24)
        font_small = ImageFont.truetype("/System/Library/Fonts/Arial.ttf", 16)
    except:
        font_large = ImageFont.load_default()
        font_small = ImageFont.load_default()
    
    # Add title
    draw.text((20, 20), "AI Generated Image", fill='#88C0D0', font=font_large)
    
    # Add prompt (wrapped)
    words = prompt.split()
    lines = []
    current_line = []
    
    for word in words:
        current_line.append(word)
        if len(' '.join(current_line)) > 35:
            lines.append(' '.join(current_line[:-1]))
            current_line = [word]
    
    if current_line:
        lines.append(' '.join(current_line))
    
    y_position = 70
    for line in lines[:6]:
        draw.text((20, y_position), line, fill='#ECEFF4', font=font_small)
        y_position += 25
    
    # Add some decorative elements
    draw.rectangle([(20, 200), (size[0]-20, 220)], fill='#5E81AC', outline='#88C0D0', width=2)
    draw.text((30, 205), "Generated by AI Pipeline", fill='#2E3440', font=font_small)
    
    # Add timestamp
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    draw.text((20, size[1]-40), f"Created: {timestamp}", fill='#88C0D0', font=font_small)
    
    return img

def create_3d_visualization(prompt):
    """Create a 3D visualization based on the prompt"""
    # Generate some 3D data based on the prompt
    # This is a simplified example - in a real app, you'd use actual 3D generation
    
    # Create a 3D surface
    x = np.linspace(-5, 5, 50)
    y = np.linspace(-5, 5, 50)
    X, Y = np.meshgrid(x, y)
    
    # Create different surfaces based on prompt keywords
    if 'mountain' in prompt.lower() or 'cliff' in prompt.lower():
        Z = np.sin(X) * np.cos(Y) * 2 + np.random.normal(0, 0.1, X.shape)
    elif 'ocean' in prompt.lower() or 'water' in prompt.lower():
        Z = np.sin(X + Y) * 0.5 + np.random.normal(0, 0.05, X.shape)
    elif 'building' in prompt.lower() or 'tower' in prompt.lower():
        Z = np.abs(X) + np.abs(Y) + np.random.normal(0, 0.1, X.shape)
    else:
        Z = np.sin(X) * np.cos(Y) + np.random.normal(0, 0.1, X.shape)
    
    # Create the 3D surface plot
    fig = go.Figure(data=[go.Surface(z=Z, x=x, y=y, colorscale='Viridis')])
    
    fig.update_layout(
        title=f'3D Visualization: {prompt[:50]}...',
        scene=dict(
            xaxis_title='X',
            yaxis_title='Y',
            zaxis_title='Z',
            camera=dict(
                eye=dict(x=1.5, y=1.5, z=1.5)
            )
        ),
        width=600,
        height=500
    )
    
    return fig

def create_point_cloud(prompt):
    """Create a 3D point cloud visualization"""
    # Generate random 3D points
    n_points = 1000
    x = np.random.normal(0, 2, n_points)
    y = np.random.normal(0, 2, n_points)
    z = np.random.normal(0, 2, n_points)
    
    # Add some structure based on prompt
    if 'sphere' in prompt.lower():
        # Create a sphere-like structure
        r = np.random.uniform(0, 2, n_points)
        theta = np.random.uniform(0, 2*np.pi, n_points)
        phi = np.random.uniform(0, np.pi, n_points)
        x = r * np.sin(phi) * np.cos(theta)
        y = r * np.sin(phi) * np.sin(theta)
        z = r * np.cos(phi)
    
    fig = go.Figure(data=[go.Scatter3d(
        x=x, y=y, z=z,
        mode='markers',
        marker=dict(
            size=3,
            color=z,
            colorscale='Viridis',
            opacity=0.8
        )
    )])
    
    fig.update_layout(
        title=f'3D Point Cloud: {prompt[:50]}...',
        scene=dict(
            xaxis_title='X',
            yaxis_title='Y',
            zaxis_title='Z'
        ),
        width=600,
        height=500
    )
    
    return fig

def main():
    st.markdown('<h1 class="main-header">ðŸŽ¨ Prompt to 3D Generator</h1>', unsafe_allow_html=True)
    st.markdown("Transform your text prompts into stunning images and 3D visualizations!")
    
    # Add warning about CPU processing
    if not torch.cuda.is_available():
        st.warning("âš ï¸ Running on CPU mode - image generation may take 1-2 minutes. For faster generation, a GPU is recommended.")
    
    # Sidebar for controls
    st.sidebar.title("ðŸŽ›ï¸ Controls")
    
    # Prompt input with character counter
    prompt = st.text_area(
        "Enter your creative prompt:",
        placeholder="e.g., A majestic dragon standing on a mountain peak at sunset",
        height=100,
        help="Be specific and descriptive for better results!"
    )
    st.caption(f"Character count: {len(prompt) if prompt else 0}/500")
    
    # Generation options
    st.sidebar.subheader("Generation Options")
    
    col1, col2 = st.sidebar.columns(2)
    with col1:
        image_size = st.selectbox(
            "Image Size",
            ["512x512", "768x768", "1024x1024"],
            help="Larger sizes take longer to generate"
        )
    with col2:
        viz_type = st.selectbox(
            "3D Visualization",
            ["Surface", "Point Cloud", "Both"],
            help="Choose visualization style"
        )
    
    # Advanced options
    with st.sidebar.expander("Advanced Options"):
        color_scheme = st.selectbox("Color Scheme", ["Viridis", "Plasma", "Inferno", "Blues"])
        detail_level = st.slider("Detail Level", 1, 10, 5)
    
    # Generate button with loading state
    if st.button("ðŸš€ Generate", type="primary", help="Click to generate image and 3D visualization"):
        if not prompt:
            st.error("Please enter a prompt first!")
            return
            
        try:
            with st.container():
                # Create tabs for different outputs
                image_tab, viz_tab, analysis_tab = st.tabs(["ðŸ–¼ï¸ Generated Image", "ðŸ”® 3D Visualization", "ðŸ“Š Analysis"])
                
                with image_tab:
                    # Generate image
                    size_map = {"512x512": (512, 512), "768x768": (768, 768), "1024x1024": (1024, 1024)}
                    img = create_image(prompt, size_map[image_size])
                    
                    # Display the image
                    st.image(img, caption=f"Generated image for: {prompt[:100]}...")
                    
                    # Add download button
                    img_buffer = io.BytesIO()
                    img.save(img_buffer, format="PNG")
                    st.download_button(
                        "â¬‡ï¸ Download Image",
                        img_buffer.getvalue(),
                        "generated_image.png",
                        "image/png"
                    )
                
                with viz_tab:
                    # Show 3D visualization with loading indicator
                    with st.spinner("ðŸ”„ Creating 3D visualization..."):
                        if viz_type in ["Surface", "Both"]:
                            st.subheader("Surface Plot")
                            fig = create_3d_visualization(prompt)
                            st.plotly_chart(fig, use_container_width=True)
                        
                        if viz_type in ["Point Cloud", "Both"]:
                            st.subheader("Point Cloud")
                            fig = create_point_cloud(prompt)
                            st.plotly_chart(fig, use_container_width=True)
                
                with analysis_tab:
                    # Show prompt analysis
                    st.subheader("Prompt Analysis")
                    col1, col2 = st.columns(2)
                    with col1:
                        st.metric("Word Count", len(prompt.split()))
                        st.metric("Character Count", len(prompt))
                    with col2:
                        st.metric("Complexity Score", detail_level)
                        st.metric("Generation Time", "See image tab")
                    
                    # Show keywords
                    keywords = [word for word in prompt.lower().split() if len(word) > 3]
                    st.write("**Keywords detected:**", ", ".join(keywords))
        
        except Exception as e:
            st.error(f"An error occurred: {str(e)}")
            st.info("Please try again with a different prompt or settings.")

if __name__ == "__main__":
    main() 